# 1363. Largest Multiple of Three
###### tags: `LeetCode` `Array` `Hard`

## 英文題目本身
Given an integer array of digits, return the largest multiple of three that can be formed by concatenating some of the given digits in any order.

Since the answer may not fit in an integer data type, return the answer as a string.

If there is no answer return an empty string.

 

Example 1:
```
Input: digits = [8,1,9]
Output: "981"
```
Example 2:
```
Input: digits = [8,6,7,1,0]
Output: "8760"
```
Example 3:
```
Input: digits = [1]
Output: ""
```
Example 4:
```
Input: digits = [0,0,0,0,0,0]
Output: "0"
```

Constraints:
```
1 <= digits.length <= 10^4
0 <= digits[i] <= 9
The returning answer must not contain unnecessary leading zeros
```
## 題目要求
給你一串數字array, 求這個array可以產生的最大可以被3整除的數字, 回傳值用String
## 想法
數學為主
3的倍數有個特性, 就是 **每個位數相加起來也會被3整除**
Basic Math
```
999....999 % 3 == 0
1000....000 % 3 == 1
a000....000 % 3 == a % 3
abcdefghijk % 3 == (a+b+c+..+i+j+k) % 3
```

所以  根據這個特性,其實可以推導出來兩種Case
1. % 3 =1 : 可以補上1個1或兩個2
2. % 3 =2 : 可以補上兩個1或1個2
但是根據上述的來弄  判斷式好複雜...

下面提供另一種想法, 直接用三個 Queue 去存 mod 3 餘 0 1 2 的三個 Queue
然後根據每個digit加總過後的 `Sum` 來去看 是`餘1`還是`餘2`
然後，這裡有個重點是  **可以先移除一個位數就先移除,因為移除一個衣錠比移除兩個的最終數字大一個位數啊！**

#### 結果
Runtime: 9 ms, faster than 100.00% 
Memory Usage: 41.8 MB, less than 100.00%
```javascript
class Solution {
    public String largestMultipleOfThree(int[] arr) {
        Arrays.sort(arr);
        /*
        Take three queues.
        queue0 for storing elements which on dividing by 3 gives remainder as 0.
        queue1 stores digits which on dividing by 3 gives remainder as 1.
        queue2 stores digits which on dividing by 3 gives remainder as 2.
         */
        Queue<Integer> queue0=new LinkedList<>();
        Queue<Integer> queue1=new LinkedList<>();
        Queue<Integer> queue2=new LinkedList<>();
        int sum=0;
        for (int a : arr) {
            sum += a;
            if (a % 3 == 0) {
                queue0.add(a);
            }
            else if (a % 3 == 1) {
                queue1.add(a);
            }
            else {
                queue2.add(a);
            }
        }
        if(sum==0) {
            return "0";
        }
        /*
        Sum of digits produces remainder 1 when divided by 3.
        Remove one item from queue1.
        If queue1 is empty, remove two items from queue2.
        If queue2 contains less than two items, the number is not possible.
         */
        if ((sum % 3) == 1) {
            if (!queue1.isEmpty()) {
                queue1.remove();
            }
            else {
                if (queue2.size() < 2) {
                    return "";
                }
                queue2.remove();
                queue2.remove();

            }
        }
        /*
        Sum of digits produces remainder 2 when divided by 3.
        Remove one item from queue2.
        If queue2 is empty, remove two items from queue1.
        If queue1 contains less than two items, the number is not possible.
         */
        else if (sum % 3 == 2)
        {
            if (!queue2.isEmpty()) {
                queue2.remove();
            }
            else {
                if(queue1.size()<2) {
                    return "";
                }
                queue1.remove();
                queue1.remove();
            }
        }

        int[] temp = new int[arr.length];
        int top= populate(temp,queue0,queue1,queue2);
        // 回傳地的top為有值的範圍
        // 把index : 0~top的的位數小到大sort一次
        Arrays.sort(temp,0,top);
        // 然後從最大的 index : top-1 開始往0一個一個加SB裡面到
        // top~最後是空的0就不理它了
        StringBuilder result = new StringBuilder();
        for (int i = top-1; i>=0; i--) {
            result.append(temp[i]);
        }

        return result.toString();

    }

    private int populate(int[] temp, Queue<Integer> queue0, Queue<Integer> queue1, Queue<Integer> queue2) {
        int top=0;
        while(!queue0.isEmpty()) {
            temp[top++] = queue0.remove();
        }
        while(!queue1.isEmpty()) {
            temp[top++]=queue1.remove();
        }
        while(!queue2.isEmpty()) {
            temp[top++]=queue2.remove();
        }
        return top;
    }
}
```

### 想法 2
#### 結果
```javascript
```